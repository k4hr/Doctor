// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum DoctorStatus {
  DRAFT
  PENDING
  NEED_FIX
  APPROVED
  REJECTED
}

enum DoctorFileKind {
  PROFILE_PHOTO
  DIPLOMA_PHOTO
}

enum QuestionStatus {
  OPEN
  IN_PROGRESS
  DONE
}

enum QuestionFileKind {
  PHOTO
}

enum AnswerCommentAuthorType {
  USER
  DOCTOR
}

enum DoctorTxType {
  IN
  OUT
}

enum DoctorTxStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELED
}

enum DoctorPayoutStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
  CANCELED
}

enum QuestionCloseStatus {
  CREATED
  PAID
}

// ===========================
// ✅ ВРАЧ.PRO (подписка)
// ===========================

enum DoctorProPlan {
  M1
  M3
  M6
  Y1
}

enum DoctorProStatus {
  ACTIVE
  EXPIRED
  CANCELED
  REFUNDED
}

model DoctorProSubscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  status DoctorProStatus @default(ACTIVE)
  plan   DoctorProPlan

  startsAt DateTime @default(now())
  endsAt   DateTime

  priceRub Int @default(199)

  provider  String?
  paymentId String? @unique

  canceledAt DateTime?
  meta       Json? @db.Json

  @@index([doctorId])
  @@index([doctorId, status])
  @@index([status])
  @@index([endsAt])
}

// ===========================
// ✅ Консультации (чат)
// ===========================

enum ConsultationStatus {
  DRAFT
  PENDING
  ACCEPTED
  DECLINED
  CLOSED
}

enum ConsultationFileKind {
  PHOTO
}

enum ConsultationMessageAuthorType {
  USER
  DOCTOR
}

model Doctor {
  id          String       @id @default(cuid())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submittedAt DateTime?
  status      DoctorStatus @default(DRAFT)

  telegramId        String  @unique
  telegramUsername  String?
  telegramFirstName String?
  telegramLastName  String?

  lastName   String
  firstName  String
  middleName String?
  gender     String
  birthDay   Int?
  birthMonth Int?
  birthYear  Int?
  city       String?

  speciality1     String
  speciality2     String?
  speciality3     String?
  education       String
  degree          String?
  workplace       String?
  position        String?
  experienceYears Int
  awards          String?

  email String

  about             String
  specialityDetails String
  experienceDetails String
  courses           String?
  achievements      String?
  publications      String?

  isOnline Boolean @default(false) @map("isonline")

  profilephotourl  String?
  profilephotocrop Json? @db.Json

  files DoctorFile[]

  assignedQuestions Question[] @relation("AssignedDoctor")
  answeredQuestions Question[] @relation("AnsweredDoctor")

  answers        Answer[]
  answerComments AnswerComment[]

  ratingSum   Int @default(0)
  ratingCount Int @default(0)

  reviews DoctorReview[]

  wallet       DoctorWallet?
  transactions DoctorTransaction[]
  payouts      DoctorPayoutRequest[]

  proUntil DateTime?
  proSubs  DoctorProSubscription[]

  // ✅ Консультации: настройка доступности и цены
  consultationEnabled  Boolean @default(false)
  consultationPriceRub Int     @default(1000)

  // ✅ Консультации: связи
  consultations Consultation[]

  @@index([status])
  @@index([speciality1])
  @@index([city])
  @@index([submittedAt])
  @@index([isOnline])
  @@index([proUntil])
  @@index([consultationEnabled])
}

model DoctorFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  kind      DoctorFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int @default(0)

  @@index([doctorId])
  @@index([kind])
  @@index([doctorId, kind])
  @@index([doctorId, kind, sortOrder])
}

model Question {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorTelegramId String
  authorUsername   String?
  authorFirstName  String?
  authorLastName   String?

  authorIsAnonymous Boolean @default(true) @map("authorisanonymous")

  speciality String
  title      String
  body       String

  keywords String[] @default([])

  editCount Int       @default(0)
  editedAt  DateTime?

  isFree   Boolean @default(true)
  priceRub Int     @default(0)

  status QuestionStatus @default(OPEN)

  assignedDoctorId String?
  assignedDoctor   Doctor? @relation("AssignedDoctor", fields: [assignedDoctorId], references: [id], onDelete: SetNull)

  answeredByDoctorId String?
  answeredByDoctor   Doctor? @relation("AnsweredDoctor", fields: [answeredByDoctorId], references: [id], onDelete: SetNull)

  files   QuestionFile[]
  answers Answer[]
  reviews DoctorReview[]
  close   QuestionClose?

  @@index([speciality])
  @@index([status])
  @@index([createdAt])
  @@index([assignedDoctorId])
  @@index([answeredByDoctorId])
  @@index([isFree])
}

model QuestionClose {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  questionId String   @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  authorTelegramId String
  status           QuestionCloseStatus @default(CREATED)

  selectedDoctorIds String[] @default([])

  totalRub     Int @default(0)
  perDoctorRub Int @default(0)

  @@index([questionId])
  @@index([authorTelegramId])
}

model QuestionFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  kind      QuestionFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int @default(0)

  @@index([questionId])
  @@index([kind])
  @@index([questionId, kind])
  @@index([questionId, kind, sortOrder])
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  body      String
  isDeleted Boolean @default(false)

  comments AnswerComment[]
  reviews  DoctorReview[]

  @@index([questionId])
  @@index([doctorId])
  @@index([questionId, createdAt])
  @@unique([questionId, doctorId])
}

model AnswerComment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  answerId String
  answer   Answer @relation(fields: [answerId], references: [id], onDelete: Cascade)

  authorType AnswerCommentAuthorType

  authorDoctorId String?
  authorDoctor   Doctor? @relation(fields: [authorDoctorId], references: [id], onDelete: Cascade)

  authorTelegramId String?
  body             String

  isDeleted Boolean @default(false)

  @@index([answerId])
  @@index([authorDoctorId])
  @@index([authorTelegramId])
  @@index([answerId, createdAt])
}

model DoctorReview {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  authorTelegramId String

  isAnonymous Boolean @default(true) @map("isanonymous")

  rating Int
  text   String?

  questionId String?
  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull)

  answerId String?
  answer   Answer? @relation(fields: [answerId], references: [id], onDelete: SetNull)

  isVerified Boolean @default(false)

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([authorTelegramId])
  @@index([questionId])
  @@index([answerId])

  @@unique([doctorId, authorTelegramId, questionId])
  @@unique([doctorId, authorTelegramId, answerId])
}

model DoctorWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String @unique
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  balanceRub Int @default(0)
  pendingRub Int @default(0)

  @@index([doctorId])
}

model DoctorTransaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  type   DoctorTxType
  status DoctorTxStatus @default(PENDING)

  amountRub Int
  title     String?
  meta      Json?

  payoutId String? @unique
  payout   DoctorPayoutRequest? @relation(fields: [payoutId], references: [id], onDelete: SetNull)

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([doctorId, type, createdAt])
  @@index([doctorId, status, createdAt])
}

model DoctorPayoutRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  amountRub Int
  status    DoctorPayoutStatus @default(PENDING)

  details Json?
  transaction DoctorTransaction?

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([doctorId, status, createdAt])
}

// ===========================
// ✅ Консультации (новые таблицы)
// ===========================

model Consultation {
  id        String             @id @default(cuid())
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  doctorId String
  doctor   Doctor             @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // пациент (как у Question)
  authorTelegramId  String
  authorUsername    String?
  authorFirstName   String?
  authorLastName    String?
  authorIsAnonymous Boolean @default(true) @map("consult_authorisanonymous")

  // текст проблемы
  body String

  // цена консультации фиксируем на момент создания
  priceRub Int @default(1000)

  status ConsultationStatus @default(DRAFT)

  files    ConsultationFile[]
  messages ConsultationMessage[]

  @@index([doctorId])
  @@index([authorTelegramId])
  @@index([status])
  @@index([createdAt])
  @@index([doctorId, status, createdAt])
  @@index([authorTelegramId, status, createdAt])
}

model ConsultationFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)

  kind      ConsultationFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int @default(0)

  @@index([consultationId])
  @@index([kind])
  @@index([consultationId, kind])
  @@index([consultationId, kind, sortOrder])
}

model ConsultationMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)

  authorType ConsultationMessageAuthorType

  authorDoctorId String?
  authorDoctor   Doctor? @relation(fields: [authorDoctorId], references: [id], onDelete: Cascade)

  authorTelegramId String?
  body             String

  isDeleted Boolean @default(false)

  @@index([consultationId])
  @@index([authorDoctorId])
  @@index([authorTelegramId])
  @@index([consultationId, createdAt])
}
