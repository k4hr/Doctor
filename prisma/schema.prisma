/* path: prisma/schema.prisma */

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum DoctorStatus {
  DRAFT
  PENDING
  NEED_FIX
  APPROVED
  REJECTED
}

enum DoctorFileKind {
  PROFILE_PHOTO
  DIPLOMA_PHOTO
}

enum QuestionStatus {
  OPEN
  IN_PROGRESS
  DONE
}

enum QuestionFileKind {
  PHOTO
}

/** Кто написал комментарий под ответом */
enum AnswerCommentAuthorType {
  USER
  DOCTOR
}

model Doctor {
  id          String       @id @default(cuid())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submittedAt DateTime?
  status      DoctorStatus @default(DRAFT)

  telegramId        String  @unique
  telegramUsername  String?
  telegramFirstName String?
  telegramLastName  String?

  lastName   String
  firstName  String
  middleName String?
  gender     String
  birthDay   Int?
  birthMonth Int?
  birthYear  Int?
  city       String?

  speciality1     String
  speciality2     String?
  speciality3     String?
  education       String
  degree          String?
  workplace       String?
  position        String?
  experienceYears Int
  awards          String?

  email String

  about             String
  specialityDetails String
  experienceDetails String
  courses           String?
  achievements      String?
  publications      String?

  files DoctorFile[]

  assignedQuestions Question[] @relation("AssignedDoctor")

  // ⚠️ Оставил как есть (у тебя уже было). Позже можно убрать/переименовать.
  answeredQuestions Question[] @relation("AnsweredDoctor")

  // ✅ Новое: врач может оставить много ответов (по форумному)
  answers Answer[]

  // ✅ Новое: врач может писать комментарии под ответами
  answerComments AnswerComment[]

  @@index([status])
  @@index([speciality1])
  @@index([city])
  @@index([submittedAt])
}

model DoctorFile {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())

  doctorId  String
  doctor    Doctor         @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  kind      DoctorFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int            @default(0)

  @@index([doctorId])
  @@index([kind])
  @@index([doctorId, kind])
  @@index([doctorId, kind, sortOrder])
}

model Question {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorTelegramId String
  authorUsername   String?
  authorFirstName  String?
  authorLastName   String?

  // ✅ В БД колонка называется authorisanonymous (lowercase)
  authorIsAnonymous Boolean @default(true) @map("authorisanonymous")

  speciality String

  title String
  body  String

  keywords String[] @default([])

  status QuestionStatus @default(OPEN)

  assignedDoctorId String?
  assignedDoctor   Doctor? @relation("AssignedDoctor", fields: [assignedDoctorId], references: [id], onDelete: SetNull)

  // ⚠️ Старое поле. При мульти-ответах становится спорным.
  // Можно оставить как "принятый/первый/лучший" врач, или удалить позже.
  answeredByDoctorId String?
  answeredByDoctor   Doctor? @relation("AnsweredDoctor", fields: [answeredByDoctorId], references: [id], onDelete: SetNull)

  files QuestionFile[]

  // ✅ Новое: ответы врачей (до 10 — ограничишь в API)
  answers Answer[]

  @@index([speciality])
  @@index([status])
  @@index([createdAt])
  @@index([assignedDoctorId])
  @@index([answeredByDoctorId])
}

model QuestionFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  kind      QuestionFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int      @default(0)

  @@index([questionId])
  @@index([kind])
  @@index([questionId, kind])
  @@index([questionId, kind, sortOrder])
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  body String

  // если потом захочешь скрывать/модерировать
  isDeleted Boolean @default(false)

  comments AnswerComment[]

  @@index([questionId])
  @@index([doctorId])
  @@index([questionId, createdAt])
  @@unique([questionId, doctorId]) // ✅ один врач = один ответ на вопрос (обычно логично)
}

model AnswerComment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  answerId String
  answer   Answer @relation(fields: [answerId], references: [id], onDelete: Cascade)

  authorType AnswerCommentAuthorType

  // Комментарий может писать либо врач (doctorId), либо пользователь (telegramId)
  authorDoctorId   String?
  authorDoctor     Doctor? @relation(fields: [authorDoctorId], references: [id], onDelete: Cascade)

  authorTelegramId String?

  body String

  isDeleted Boolean @default(false)

  @@index([answerId])
  @@index([authorDoctorId])
  @@index([authorTelegramId])
  @@index([answerId, createdAt])
}
