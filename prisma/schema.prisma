// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum DoctorStatus {
  DRAFT
  PENDING
  NEED_FIX
  APPROVED
  REJECTED
}

enum DoctorFileKind {
  PROFILE_PHOTO
  DIPLOMA_PHOTO
}

enum QuestionStatus {
  OPEN
  IN_PROGRESS
  DONE
}

enum QuestionFileKind {
  PHOTO
}

// Кто написал комментарий под ответом
enum AnswerCommentAuthorType {
  USER
  DOCTOR
}

// ✅ Финансы врача
enum DoctorTxType {
  IN
  OUT
}

enum DoctorTxStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELED
}

enum DoctorPayoutStatus {
  PENDING
  APPROVED
  PAID
  REJECTED
  CANCELED
}

model Doctor {
  id          String       @id @default(cuid())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  submittedAt DateTime?
  status      DoctorStatus @default(DRAFT)

  telegramId        String  @unique
  telegramUsername  String?
  telegramFirstName String?
  telegramLastName  String?

  lastName   String
  firstName  String
  middleName String?
  gender     String
  birthDay   Int?
  birthMonth Int?
  birthYear  Int?
  city       String?

  speciality1     String
  speciality2     String?
  speciality3     String?
  education       String
  degree          String?
  workplace       String?
  position        String?
  experienceYears Int
  awards          String?

  email String

  about             String
  specialityDetails String
  experienceDetails String
  courses           String?
  achievements      String?
  publications      String?

  // ✅ ручной онлайн/оффлайн
  // В БД колонка была создана как "isonline" (lowercase), поэтому маппим:
  isOnline Boolean @default(false) @map("isonline")

  // ✅ НОВОЕ: одно фото врача + кроп миниатюры (храним прямо в Doctor)
  // В БД создай колонки НИЖЕ ИМЕННО ТАК (lowercase)
  profilephotourl  String?
  profilephotocrop Json? @db.Json

  files DoctorFile[]

  assignedQuestions Question[] @relation("AssignedDoctor")

  // ⚠️ Оставил как есть (у тебя уже было). Позже можно убрать/переименовать.
  answeredQuestions Question[] @relation("AnsweredDoctor")

  // ✅ Новое: врач может оставить много ответов (по форумному)
  answers Answer[]

  // ✅ Новое: врач может писать комментарии под ответами
  answerComments AnswerComment[]

  // ✅ Рейтинг (агрегаты по отзывам)
  ratingSum   Int @default(0) // сумма всех оценок 1..5
  ratingCount Int @default(0) // количество отзывов

  // ✅ Отзывы о враче
  reviews DoctorReview[]

  // ✅ Финансы
  wallet       DoctorWallet?
  transactions DoctorTransaction[]
  payouts      DoctorPayoutRequest[]

  @@index([status])
  @@index([speciality1])
  @@index([city])
  @@index([submittedAt])
  @@index([isOnline])
}

model DoctorFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  kind      DoctorFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int @default(0)

  @@index([doctorId])
  @@index([kind])
  @@index([doctorId, kind])
  @@index([doctorId, kind, sortOrder])
}

model Question {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorTelegramId String
  authorUsername   String?
  authorFirstName  String?
  authorLastName   String?

  // ✅ В БД колонка называется authorisanonymous (lowercase)
  authorIsAnonymous Boolean @default(true) @map("authorisanonymous")

  speciality String

  title String
  body  String

  keywords String[] @default([])

  status QuestionStatus @default(OPEN)

  assignedDoctorId String?
  assignedDoctor   Doctor? @relation("AssignedDoctor", fields: [assignedDoctorId], references: [id], onDelete: SetNull)

  // ⚠️ Старое поле. При мульти-ответах становится спорным.
  // Можно оставить как "принятый/первый/лучший" врач, или удалить позже.
  answeredByDoctorId String?
  answeredByDoctor   Doctor? @relation("AnsweredDoctor", fields: [answeredByDoctorId], references: [id], onDelete: SetNull)

  files QuestionFile[]

  // ✅ Новое: ответы врачей (до 10 — ограничишь в API)
  answers Answer[]

  // ✅ Отзывы могут быть привязаны к вопросу (опционально)
  reviews DoctorReview[]

  @@index([speciality])
  @@index([status])
  @@index([createdAt])
  @@index([assignedDoctorId])
  @@index([answeredByDoctorId])
}

model QuestionFile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  kind      QuestionFileKind
  url       String
  mime      String?
  sizeBytes Int?
  sortOrder Int @default(0)

  @@index([questionId])
  @@index([kind])
  @@index([questionId, kind])
  @@index([questionId, kind, sortOrder])
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  body String

  // если потом захочешь скрывать/модерировать
  isDeleted Boolean @default(false)

  comments AnswerComment[]

  // ✅ Отзывы могут быть привязаны к конкретному ответу (опционально)
  reviews DoctorReview[]

  @@index([questionId])
  @@index([doctorId])
  @@index([questionId, createdAt])
  @@unique([questionId, doctorId]) // ✅ один врач = один ответ на вопрос (обычно логично)
}

model AnswerComment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  answerId String
  answer   Answer @relation(fields: [answerId], references: [id], onDelete: Cascade)

  authorType AnswerCommentAuthorType

  // Комментарий может писать либо врач (doctorId), либо пользователь (telegramId)
  authorDoctorId   String?
  authorDoctor     Doctor? @relation(fields: [authorDoctorId], references: [id], onDelete: Cascade)

  authorTelegramId String?

  body String

  isDeleted Boolean @default(false)

  @@index([answerId])
  @@index([authorDoctorId])
  @@index([authorTelegramId])
  @@index([answerId, createdAt])
}

model DoctorReview {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Кто оставил отзыв (обычный пользователь)
  authorTelegramId String

  // 1..5 (в API валидируешь)
  rating Int

  // Текст отзыва (опционально)
  text String?

  // Можно привязать отзыв к конкретному вопросу/ответу (после "принял ответ")
  questionId String?
  question   Question? @relation(fields: [questionId], references: [id], onDelete: SetNull)

  answerId String?
  answer   Answer? @relation(fields: [answerId], references: [id], onDelete: SetNull)

  // На будущее (модерация/оплата/подтверждение)
  isVerified Boolean @default(false)

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([authorTelegramId])
  @@index([questionId])
  @@index([answerId])
}

// ✅ 1:1 кошелек врача
model DoctorWallet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String @unique
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Храним в рублях (Int). Если захочешь копейки — сделаем в копейках.
  balanceRub Int @default(0) // доступно к выводу
  pendingRub Int @default(0) // в обработке на вывод

  @@index([doctorId])
}

// ✅ транзакции по кошельку
model DoctorTransaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  type   DoctorTxType
  status DoctorTxStatus @default(PENDING)

  amountRub Int
  title     String?
  meta      Json?

  // ✅ FIX: чтобы связь payout <-> transaction была 1:1, payoutId должен быть unique
  payoutId String? @unique
  payout   DoctorPayoutRequest? @relation(fields: [payoutId], references: [id], onDelete: SetNull)

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([doctorId, type, createdAt])
  @@index([doctorId, status, createdAt])
}

// ✅ заявки на вывод
model DoctorPayoutRequest {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorId String
  doctor   Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  amountRub Int
  status    DoctorPayoutStatus @default(PENDING)

  // реквизиты/метод можно хранить в JSON (позже прикрутим карту/счёт)
  details Json?

  transaction DoctorTransaction?

  @@index([doctorId])
  @@index([doctorId, createdAt])
  @@index([doctorId, status, createdAt])
}
